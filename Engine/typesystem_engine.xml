<?xml version="1.0"?>
<!--  Natron
 
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 Created by Alexandre GAUTHIER-FOICHAT on 6/1/2012.
 contact: immarespond at gmail dot com
 -->
<typesystem package="NatronEngine">
    
    <!--Load QtCore typesystem-->
    <load-typesystem name="typesystem_core.xml" generate="no" />
    
    <!--Templates for type conversions used many times-->
    <load-typesystem name="typesystem_templates.xml" generate="no"/>
    
    <!--The custom-type node simply makes the parser aware of the existence of a target language type, thus avoiding errors when trying to find a type used in function signatures and other places. The proper handling of the custom type is meant to be done by a generator using the APIExractor.-->
    <custom-type name="PyObject"/>
    
    <!--Primitives-->
    <primitive-type name="bool"/>
    <primitive-type name="double"/>
    <primitive-type name="real"/>
    <primitive-type name="int"/>
    <primitive-type name="short"/>
    <primitive-type name="unsigned short"/>
    <primitive-type name="ushort"/>
    <primitive-type name="unsigned int" />
    <primitive-type name="signed int" />
    <primitive-type name="char"/>
    <primitive-type name="unsigned char"/>
    <primitive-type name="long"/>
    <primitive-type name="unsigned long"/>
    <primitive-type name="long long"/>
    <primitive-type name="unsigned long long"/>
    <primitive-type name="std::string"/>
     <!--   <conversion-rule>
            <native-to-target>
                PyObject* %out = PyString_AsStringAndSize(%in.c_str(),%in.size());
                return %out;
            </native-to-target>
            <target-to-native>
                <add-conversion type="PyObject">
                    char* cstr = PyString_AsString(%in);
                    %out = std::string(cstr);
                    return %out;
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </primitive-type>-->
    
    <primitive-type name="std::size_t" target-lang-api-name="PyLong">
        <conversion-rule>
            <native-to-target>
                return PyLong_FromSize_t(%in);
            </native-to-target>
            <target-to-native>
                <add-conversion type="PyLong">
                    %out = %OUTTYPE(PyLong_AsSsize_t(%in));
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </primitive-type>
    
    <!--std::pair from/to Python pair-->
    <container-type name="std::pair" type="pair">
        <include file-name="utility" location="global"/>
        <conversion-rule>
            <native-to-target>
                PyObject* %out = PyTuple_New(2);
                PyTuple_SET_ITEM(%out, 0, %CONVERTTOPYTHON[%INTYPE_0](%in.first));
                PyTuple_SET_ITEM(%out, 1, %CONVERTTOPYTHON[%INTYPE_1](%in.second));
                return %out;
            </native-to-target>
            <target-to-native>
                <add-conversion type="PySequence">
                    %out.first = %CONVERTTOCPP[%OUTTYPE_0](PySequence_Fast_GET_ITEM(%in, 0));
                    %out.second = %CONVERTTOCPP[%OUTTYPE_1](PySequence_Fast_GET_ITEM(%in, 1));
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </container-type>
    
    <!--std::list from/to Python list-->
    <container-type name="std::list" type="list">
        <include file-name="list" location="global"/>
        <conversion-rule>
            <native-to-target>
                <insert-template name="stdListToPyList"/>
            </native-to-target>
            <target-to-native>
                <add-conversion type="PySequence">
                    <insert-template name="pyListToStdList"/>
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </container-type>
    
    <!--std::vector from/to Python list-->
    <container-type name="std::vector" type="vector">
        <include file-name="vector" location="global"/>
        <conversion-rule>
            <native-to-target>
                <insert-template name="stdVectorToPyList"/>
            </native-to-target>
            <target-to-native>
                <add-conversion type="PySequence">
                    <insert-template name="pySeqToStdVector"/>
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </container-type>
    
    <!--std::set from/to Python map-->
    <container-type name="std::set" type="set">
        <include file-name="set" location="global"/>
        <conversion-rule>
            <native-to-target>
                <insert-template name="stdListToPyList"/>
            </native-to-target>
            <target-to-native>
                <add-conversion type="PySequence">
                    <insert-template name="pyListToStdList"/>
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </container-type>

    <!--std::map from/to Python map-->
    <container-type name="std::map" type="map">
        <include file-name="map" location="global"/>
        <conversion-rule>
            <native-to-target>
                <insert-template name="stdMapToPyDict"/>
            </native-to-target>
            <target-to-native>
                <add-conversion type="PyDict">
                    <insert-template name="pyDictToStdMap"/>
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </container-type>
    
    <!--std::multimap from/to Python map-->
    <container-type name="std::multimap" type="multi-map">
        <include file-name="map" location="global"/>
        <conversion-rule>
            <native-to-target>
                <insert-template name="stdMapToPyDict"/>
            </native-to-target>
            <target-to-native>
                <add-conversion type="PyDict">
                    <insert-template name="pyDictToStdMap"/>
                </add-conversion>
            </target-to-native>
        </conversion-rule>
    </container-type>
    
     <!--Natron global enums-->
    <namespace-type name="Natron">
    <enum-type name="StandardButton" flags="StandardButtons"/>
    <enum-type name="KeyframeType"/>
    <enum-type name="PixmapEnum"/>
    <enum-type name="ValueChangedReason"/>
    <enum-type name="AnimationLevel"/>
    <enum-type name="ImageComponents"/>
    <enum-type name="ImageBitDepth"/>
    <enum-type name="ImagePremultiplication"/>
    <enum-type name="ViewerCompositingOperator"/>
    <enum-type name="ViewerColorSpace"/>
    <enum-type name="Orientation"/>
    <enum-type name="PlaybackMode"/>
    </namespace-type>
    
    <!--Global functions to Natron process-->
    <function signature="getPluginIDs()"/>
    <function signature="getNumInstances()"/>


</typesystem>



<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1187.4">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Helvetica}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Helvetica; min-height: 12.0px}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 17.0px Helvetica}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p8 {margin: 0.0px 0.0px 0.0px 48.0px; text-indent: -48.0px; font: 12.0px Helvetica}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.0px Helvetica}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
    p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Menlo; color: #ffffff; min-height: 13.0px}
    p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Menlo}
    p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Menlo; color: #323333}
    p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: right; font: 12.0px Menlo; min-height: 14.0px}
    p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Helvetica}
    p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Menlo; min-height: 13.0px}
    p.p20 {margin: 0.0px 0.0px 19.0px 0.0px; font: 12.0px Times}
    p.p21 {margin: 0.0px 0.0px 16.0px 0.0px; font: 12.0px Times}
    li.li5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica; color: #0000ee}
    li.li7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    li.li9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
    li.li11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
    li.li18 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Menlo; color: #0000ee}
    li.li19 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Helvetica}
    li.li22 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times}
    li.li23 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #042eee}
    span.s1 {text-decoration: underline}
    span.s2 {color: #000000}
    span.s3 {color: #2e6ffd}
    span.s4 {font: 12.0px Helvetica; text-decoration: underline}
    span.s5 {text-decoration: underline ; color: #0000ee}
    span.s6 {font: 15.0px Helvetica; color: #c67c48}
    span.s7 {color: #d28f5a}
    span.s8 {font: 11.0px Helvetica; color: #000000}
    span.s9 {font: 11.0px Menlo; color: #0000ee}
    span.s10 {font: 11.0px Menlo}
    span.s11 {font: 18.0px Helvetica}
    span.s12 {font: 11.0px Menlo; color: #d28f5a}
    span.s13 {font: 14.0px Helvetica}
    span.Apple-tab-span {white-space:pre}
    table.t1 {background-color: #ffffff; border-collapse: collapse}
    td.td1 {width: 764.0px; padding: 0.0px 10.0px 0.0px 10.0px}
    td.td2 {width: 764.0px; border-style: solid; border-width: 0.0px 1.0px 0.0px 0.0px; border-color: transparent #eeeeee transparent transparent; padding: 0.0px 10.0px 0.0px 10.0px}
    ol.ol1 {list-style-type: decimal}
    ul.ul1 {list-style-type: disc}
  </style>
</head>
<body>
<p class="p1"><b>OpenFX plug-in programming guide (C/C++)</b></p>
<p class="p2"><br></p>
<p class="p3"><i>- 1st draft 08/24/2014 </i>Alexandre Gauthier-Foichat</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p1"><b><i>Table of contents</i></b></p>
<p class="p4"><br></p>
<ol class="ol1">
  <li class="li5"><span class="s1">Introduction</span><span class="s2"><span class="Apple-converted-space"> </span></span></li>
  <li class="li5"><span class="s1">Presentation of the Support layer</span></li>
  <li class="li5"><span class="s1">Walkthrough : The Invert plug-in</span></li>
</ol>
<p class="p4"><br></p>
<p class="p2"><br></p>
<p class="p6"><b>Introduction</b></p>
<p class="p2"><br></p>
<p class="p7">First off, the main <i>official</i> specification can be found right there <a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html"><span class="s3">http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html</span></a><span class="s3"> </span>and should be followed very precisely when in case of doubt. This document is 100% true and answers almost all questions one might have. However this is a quite long document which can be quite hard to swallow the first time one has to read it.</p>
<p class="p2"><br></p>
<p class="p7">I'll skip all the details regarding packaging of OpenFX pug-ins and the philosophy and focus this document on the programming of OpenFX plug-ins using the <b>Support</b> layer.</p>
<p class="p7">What is the <b>Support</b> layer?</p>
<p class="p2"><br></p>
<p class="p7">OpenFX is in under the hood just a protocol for a plug-in and a host application to help communicate.</p>
<p class="p7">They do so with a C API using <i>blind</i> <i>handles</i> and properties which are uniquely identified by names, which all begins with kOfx* .</p>
<p class="p7">To help using this API, the official guys from the OpenFX association have made a C++ wrapper around it so it is easier to use. The wrapper on the plug-in side is called the <b>Support</b> layer and the one on the Host side (the application, e.g: Natron) is called the <b>HostSupport</b> layer.</p>
<p class="p2"><br></p>
<p class="p7">The official repository of the OpenFX association is no longer actively maintained. That's why the Natron dev team has forked it and continue maintaining it and fixing bugs whilst also incorporating new features of the newer versions of OpenFX.</p>
<p class="p7">The official repository of the OpenFX association can be found here: <a href="https://github.com/ofxa/openfx"><span class="s3">https://github.com/ofxa/openfx</span></a></p>
<p class="p7">The repository the Natron dev team maintains can be found here: <a href="https://github.com/devernay/openfx"><span class="s3">https://github.com/devernay/openfx</span></a></p>
<p class="p2"><br></p>
<p class="p7">On this repository you will find the 2 layers mentioned above in separate folders with their respective names.</p>
<p class="p7">The Examples directory contains OpenFX plug-in examples which were programmed using directly the C API (thus not using the <b>Support</b> layer).</p>
<p class="p7">The <b>Support</b> folder contains a Plugins folder which contains other examples. These examples are on the other hand programmed using the <b>Support</b> layer.</p>
<p class="p2"><br></p>
<p class="p7">The Natron dev team has 2 separate repositories for its OpenFX plug-ins.</p>
<p class="p2"><br></p>
<p class="p8">One is to handle all plug-ins which do input/output operations and rely on external libraries (such as OpenImageIO, OpenColorIO,FFMPEG,OpenEXR, etc…) and can be found here: <a href="https://github.com/MrKepzie/openfx-io"><span class="s3">https://github.com/MrKepzie/openfx-io</span></a></p>
<p class="p8">The other one is for all other plug-ins which do image processing. They do not require linking to any other external library and are generally easier to compile and understand. The address of that repository is: <a href="https://github.com/devernay/openfx-misc"><span class="s3">https://github.com/devernay/openfx-misc</span></a></p>
<p class="p2"><br></p>
<p class="p7">Depending on what kind of plug-in you implement you should base your work upon one of the 2 repositories above as they contain "state of the art" OpenFX plug-ins. They use the OpenFX API as one should do.</p>
<p class="p7">If you were to create a new reader plug-in to read whatever you need that isn't supported already, I suggest that you fork openfx-io and derive the GenericReader class which does all the quite complex handling of what a fully-featured reader plug-in is expected to do (such as downscaling, color-space transformation) . Same for writer plug-ins, I suggest you derive the GenericWriter class.</p>
<p class="p2"><br></p>
<p class="p7">If on the other hand you were to write an image processing plug-in, I suggest you fork the openfx-misc repository and look at the plug-ins inside as examples. The Crop and Invert plug-ins are trivial plug-ins which should give you a fair understanding on how OpenFX works.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p6"><b>Architecture of a plug-in</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">A plug-in is a folder on Windows/Linux and a bundle on MacOSX which can be represented as follows:</p>
<p class="p2"><br></p>
<p class="p7">MyPlugin.ofx.bundle/</p>
<p class="p7">Contents/</p>
<p class="p7">Win32/</p>
<p class="p7">MyPlugin.ofx</p>
<p class="p7">Win64/</p>
<p class="p7">MyPlugin.ofx</p>
<p class="p7">Resource/</p>
<p class="p7">MyPlugin.svg</p>
<p class="p2"><br></p>
<p class="p7">The .ofx is just a .so on Linux, a .dylib on MacOSX and a .dll on Windows whose extension has been renamed to .ofx.</p>
<p class="p7">For an extensive explanation of the details of how the bundle should be setup, please refer to</p>
<p class="p9"><span class="s1"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#id449875">http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#id449875<span class="s4"></span></a></span></p>
<p class="p2"><br></p>
<p class="p6"><b>Communication between the host and a plug-in</b></p>
<p class="p2"><br></p>
<p class="p7">Each plug-in can be instantiated in different context by an application depending on its use.</p>
<p class="p7">They are well described in the OpenFX specification and won't go through them here.</p>
<p class="p9"><span class="s1"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#ImageEffectContexts">http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#ImageEffectContexts<span class="s4"></span></a></span></p>
<p class="p2"><br></p>
<p class="p7">The OpenFX spec. defines functions that the host can call on the plug-ins to make it perform special actions. These functions are called <b>actions</b> and their specification is well described here:</p>
<p class="p9"><span class="s1"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#id473661">http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#id473661<span class="s4"></span></a></span></p>
<p class="p7">The most important action to implement in general is the render action which is called when a plug-in needs to render its image. We will detail a bit more the important actions in the chapter dedicated to the plug-in object.</p>
<p class="p2"><br></p>
<p class="p7">The plug-in can also call some functions on the host to query some informations. These functions are grouped in "<i>suites</i>". Generally the type of things you would like to ask is "fetch that image", "fetch that image's size", etc…</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p6"><b>Using the C++ Support Layer</b></p>
<p class="p2"><br></p>
<p class="p7">A C++ plug-in is composed of 3 objects in the general cases:</p>
<p class="p2"><br></p>
<p class="p8">The <b><i>factory</i></b> object which is used to instantiate the plug-in to the host application at the moment the binary is loaded.</p>
<p class="p8">The <b><i>plug-in</i></b> object which is used to communicate with the host application and do some work. Generally the processing is not done in this object, rather we do it in the last object…</p>
<p class="p8">The <b><i>processor</i></b> object which is used to do the processing in an optimised way: OpenFX offers a way to do multi-threading easily using this class.</p>
<p class="p7">The last class is not mandatory and one could also do the rendering in the plug-in class, though it would not be multi-threaded.</p>
<p class="p2"><br></p>
<p class="p6"><b>The factory</b></p>
<p class="p2"><br></p>
<p class="p7">It basically serves 3 purposes:</p>
<p class="p8">Instantiating the <b><i>plug-in</i></b> object.</p>
<p class="p8">Declaring some parameters/clips: This is done in the <b>describeInContext</b> function. The parameters are what the user *could* (generally can, but not if they are hidden/disabled) interact with in the user interface. They are several types of parameters and they are quite well described in the specification:</p>
<p class="p8"><span class="s5"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#ParametersChapter">http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#ParametersChapter</a></span> . What you can control is whether the user can animate them, their name, default value, etc… Please check out the examples in the openfx-misc for implementation details.</p>
<p class="p8">The clips are the objects that refer the input images (in Natron a clip is the arrow between 2 nodes). This is a view of the plug-in of another input plug-in. The plug-in must always define an output clip: This is where the output image of this plug-in will be defined.</p>
<p class="p2"><br></p>
<p class="p8">Declaring some properties of the plug-in to the host application. This is done in the <b>describe</b> function. This is where the plug-in defines its name, which bit depths it can support,, whether it can support multi-resolution images, whether it will need fetching images at different times, whether it supports interlaced images, whether it supports multi-threading…. etc</p>
<p class="p9"><span class="s2">See the invert plug-in describe function here <a href="https://github.com/devernay/openfx-misc/blob/master/Invert/Invert.cpp"><span class="s4">https://github.com/devernay/openfx-misc/blob/master/Invert/Invert.cpp</span></a></span></p>
<p class="p7">for an example of the function.</p>
<p class="p7">All properties defined in the <b>describe</b> function are well covered by the OpenFX specification though some need some extra caution:</p>
<p class="p2"><br></p>
<p class="p7">- <a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPluginRenderThreadSafety"><span class="s6">kOfxImageEffectPluginRenderThreadSafety</span></a><span class="s6"> </span>: This must be carefully set. If misused, then your plug-in might not be thread-safe.</p>
<p class="p8">Unsafe means that all instances of the same plug-in can only have 1 render-thread at once: they will all be synchronised.</p>
<p class="p8">InstanceSafe means that an instance can only have 1 render thread at a time, though several instances do not need special synchronisation.</p>
<p class="p8">FullySafe indicating that any instance of a plug-in can have multiple render threads running simultaneously.</p>
<p class="p7">On top of that the plug-in can also set the property <a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPluginPropHostFrameThreading"><span class="s6">kOfxImageEffectPluginPropHostFrameThreading</span></a><span class="s6"> </span>: When set to 1, and if the thread-safety of the plug-in permits, the host will slice the render window and call it with several threads instead of calling the render function with only 1 thread.</p>
<p class="p7">Bear in mind that you as a plug-in do not need to set this to 1 since you can use the multi-thread suite and do the multi-threading yourself. This suite also includes locking abilities allowing you to properly control the thread-safety of your plug-in.</p>
<p class="p7">- <a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropSupportsMultiResolution"><span class="s6">kOfxImageEffectPropSupportsMultiResolution</span></a><span class="s6"> </span>: When set to 1 that means your plug-in is expected to work with arbitrary image rectangles in input and output and they may not necessarily be the same.</p>
<p class="p2"><br></p>
<p class="p7">- <a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropSupportsTiles"><span class="s6">kOfxImageEffectPropSupportsTiles</span></a><span class="s6"> </span>: When set to 1 that means your plug-in is expected to work with images that are not the "full image" but just a sub-rectangle of the full image.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p6"><b>The plug-in object</b></p>
<p class="p2"><br></p>
<p class="p7">This is the main object allowing to bridge with the application. When implementing your plug-in you will want to derive the OFX::ImageEffect class. There are a bunch of virtual functions which are the <b>actions</b> the host application can call. (The functions I mentioned above).</p>
<p class="p2"><br></p>
<p class="p7">The constructor of the plug-in is here to fetch a pointer to all the parameters/clip you defined previously in the <b>describe</b> function of the factory. These pointers represent the "instantiated" version of those parameters/clip, whereas in the <b>describe</b> function well…you just <b>described</b> them so the host would instantiate them correctly. This is with those pointers that you can get/set values and query informations.</p>
<p class="p2"><br></p>
<p class="p7">The output clip (sometimes called dstClip_ in our examples) represents the output image.</p>
<p class="p7">The source clip represents the source image and this is from this object that you need to fetch the input image.</p>
<p class="p7">If you were to have several input clips, then you would fetch the input images from each of your source clips.</p>
<p class="p7">Some clips can be optional (such as a mask for example) and needs to be set so explicitly in the describe function of the factory.</p>
<p class="p2"><br></p>
<p class="p7">In the following I will vaguely re-explain the main actions that are generally implemented by a plug-in. Though for more detailed explanation and how to report errors in these functions please check the OpenFX specification which does a full coverage on them.</p>
<p class="p2"><br></p>
<p class="p6"><b>The isIdentity action</b></p>
<p class="p10">virtual bool isIdentity(const IsIdentityArguments &amp;args, Clip * &amp;identityClip, double &amp;identityTime) OVERRIDE FINAL</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">This function must return true if the effect in its current state will not apply any change to the source image. This is called by the host to determine whether a call to the render action is necessary or not.</p>
<p class="p7">When true then the rendering pipeline is much faster as the host just skips this plug-in from the compositing tree.</p>
<p class="p7">The identityClip parameter must be set to a pointer of the input clip of which the effect is an identity of.</p>
<p class="p7">The identityTime parameter must be set to the time at which the effect is an identity of the input clip.</p>
<p class="p7">For example a gain effect whose "Scale" parameter would be set to 1 would be an identity.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p6"><b>The changedParam action</b></p>
<p class="p10">virtual void changedParam(const OFX::InstanceChangedArgs &amp;args, const std::string &amp;paramName) OVERRIDE FINAL;</p>
<p class="p2"><br></p>
<p class="p7">This function is called every time a parameter is changed. This function can be called either because you set the value of a parameter programmatically or because the user interacted with the parameter.</p>
<p class="p7">the args.reason parameter will inform you from what this function was called.</p>
<p class="p7">For example if you had a button parameter, when the user would press it, it would call this function with the args.reason == eChangeUserEdit.</p>
<p class="p2"><br></p>
<p class="p7">This function is also a great place to show/hide and enable/disable other parameters according to special values of another parameter.</p>
<p class="p2"><br></p>
<p class="p7">This function could be used to implement analysis effects (such as a tracker). Fetching an image is allowed in this action.</p>
<p class="p2"><br></p>
<p class="p6"><b>The getRegionOfDefinition action</b></p>
<p class="p10">virtual bool getRegionOfDefinition(const OFX::RegionOfDefinitionArguments &amp;args, OfxRectD &amp;rod) OVERRIDE FINAL;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">This is called by the host to determine the size of the image (or region of definition) produced by this effect.</p>
<p class="p7">If your plug-in doesn't apply any geometrical transformation to the image, then it is probably not modifying it's size (e.g: an Invert plug-in doesn't modify the image's region of definition.) In that case you do not need to implement this function, this is the default behaviour to return the region of definition of the source clip.</p>
<p class="p7">On the other hand, a crop effect would return the size of the crop area as its region of definition.</p>
<p class="p2"><br></p>
<p class="p6"><b>The getRegionsOfInterest action</b></p>
<p class="p10">virtual void getRegionsOfInterest(const OFX::RegionsOfInterestArguments &amp;args, OFX::RegionOfInterestSetter &amp;rois) OVERRIDE FINAL;</p>
<p class="p2"><br></p>
<p class="p7">Even though the name is close to the getRegionOfDefinition action, it doesn't serve the same purpose at all!</p>
<p class="p7">This function is called by the host before the render action is called. This is called when it wants to pre-render the input images this effect might need. In order to do so, the host needs to ask this effect what is the rectangle of the source image we're interested in. This is the purpose of this action. In general if your plug-in does need exactly the render window then you don't have to implement this function. On the other hand , a blur plug-in might have to include the border padding to the region of interest of the input clip.</p>
<p class="p2"><br></p>
<p class="p6"><b>The getClipPreferences action</b></p>
<p class="p10">virtual void getClipPreferences(ClipPreferencesSetter &amp;clipPreferences) OVERRIDE FINAL;</p>
<p class="p2"><br></p>
<p class="p7">You rarely need to implement this action. This action is called by the host to allow the effect to perform modifications of the state of the clip, such as its premultiplication (is the image premultiplied or not?) or the image components (is it alpha, RGB or RGBA?) or image bit depth (is it byte, short or float ?)</p>
<p class="p7">For example the shuffle plug-ins uses it when the users chooses different output components or different bit depth.</p>
<p class="p2"><br></p>
<p class="p6"><b>The render action</b></p>
<p class="p10">virtual void render(const OFX::RenderArguments &amp;args) OVERRIDE FINAL;</p>
<p class="p2"><br></p>
<p class="p7">This is where the processing must be done. The args contain several parameters that define how the image should be rendered.</p>
<p class="p8">time: The time at which the render is taking place. This can be used to fetch the input images at the same time or at other times.</p>
<p class="p8">renderScale: When different than 1 this informs that the image is rendered at a lower resolution than the full resolution. For example this is used in Natron when the user zooms out. As a filter plug-in , this is merely an hint and doesn't hold much value. On the other hand for a reader effect (such as the ones in openfx-io) this is clearly stating at which scale you should read the image. In this case you should explicitly downscale the image yourself (ONLY FOR READER PLUG-INS!!). If you don't support downscaling the images, then in all the actions called by the host, you're expected to check the render scale parameter and throw a kOfxStatFailed exception if the render scale is different than 1. This can in turn inform the host that you don't support the downscaling of the images and it will take care of it for you.</p>
<p class="p8">renderWindow: This is the portion of the image to render. If you specified that you support tiles in the describe function of the factory then it might not be the full <b>region of definition</b> of the image.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">To fetch input images, call the fetchImage on the source clips at the desired time. You're expected to check whether the input clip is connected before fetching the image (i.e: call getConnected() on the clip). A clip is connected in Natron when the arrow is connected to another effect.</p>
<p class="p7">If you cannot use the input image for any reason (bad bit depth, bad components, etc…) then your expected to throw a significant exception to indicate that the render failed (kOfxErrBadFormat).</p>
<p class="p11"><b>You can only fetch an image during the render action or the changedParam action</b></p>
<p class="p2"><br></p>
<p class="p7">Generally a plug-in is better if it can handle arbitrary bit depths and image components. To deal with that in our plug-ins we template the internal render function by the components and the bit depth.</p>
<p class="p7">For example in the Invert plug-in of the openfx-misc repository, the render function just instantiate the templated class ImageInverter with the good template parameters depending on the bit depth and the image components.</p>
<p class="p2"><br></p>
<p class="p7">In this example we use the processor object (ImageInverter) to do the rendering because it enables the multi-threading offered by the host, but we could clearly do the processing in the render function, though, it wouldn't be multi-threaded (unless we would have set the <a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPluginPropHostFrameThreading"><span class="s6">kOfxImageEffectPluginPropHostFrameThreading</span></a><span class="s6"> </span>property to 1).</p>
<p class="p2"><br></p>
<p class="p6"><b>The processor</b></p>
<p class="p2"><br></p>
<p class="p7">The host application can implement the multi-thread suite. Remember, a suite is a set of functions that a host can implement, offering some functionalities to the plug-in. In this case this suite is designed to offer SMP style multi-processing.</p>
<p class="p7">The C++ processor class is just a wrapper around this suite so that it is easier for you, as a plug-in developer, to multi-thread your processing. You would need to derive the OFX::ImageProcessor to craft your own processor.</p>
<p class="p7">The only function you have to override is the <b>multiThreadProcessImages </b>function. This is the core render function which renders an image rectangle for a single thread. You can cycle through all the examples for inspiration on how the processing is generally written, though the inner part of the pixel processing is really up to the plug-in developer.</p>
<p class="p2"><br></p>
<p class="p7">Bear in mind that it is more efficient to get all the values from the parameters before calling the processor multithread function. In order to do that we generally fetch all the values we want in the render function (or more specifically in the setupAndProcess function) and then give it in parameter to the processor class.</p>
<p class="p7">The getValue function of a parameter can be quite expensive and it's better to call it once if you can.</p>
<p class="p7">Same applies for the fetchImage function.</p>
<p class="p2"><br></p>
<p class="p6"><b>Walkthrough: The invert plug-in</b></p>
<p class="p2"><br></p>
<p class="p7">In this part we will examine the source code of the <a href="https://github.com/devernay/openfx-misc/tree/master/Invert"><span class="s5">Invert plug-in</span></a><span class="Apple-converted-space">  </span>and comment the relevant parts.</p>
<p class="p2"><br></p>
<p class="p7">First, let's take a look at the <a href="https://github.com/devernay/openfx-misc/blob/master/Invert/PluginRegistration.cpp"><span class="s5">PluginRegistration.cpp</span></a> file.</p>
<p class="p7">Any plug-in must register in the following function a static factory of the plug-in:</p>
<p class="p2"><br></p>
<p class="p12"><br></p>
<p class="p13">namespace OFX</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>namespace Plugin</p>
<p class="p13"><span class="Apple-converted-space">    </span>{</p>
<p class="p13"><span class="Apple-converted-space">        </span>void getPluginIDs(OFX::PluginFactoryArray &amp;ids)</p>
<p class="p13"><span class="Apple-converted-space">        </span>{</p>
<p class="p13"><span class="Apple-converted-space">            </span>...</p>
<p class="p13"><span class="Apple-converted-space">        </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p13">}</p>
<p class="p2"><br></p>
<p class="p7">In the invert example, we made a function in the plug-in named getInvertPluginID, declared in <a href="https://github.com/devernay/openfx-misc/blob/master/Invert/Invert.h"><span class="s5">Invert.h</span></a> , defined in <a href="https://github.com/devernay/openfx-misc/blob/master/Invert/Invert.cpp"><span class="s5">Invert.cpp</span></a> and in that function we just instantiate our factory that we declared above:</p>
<p class="p2"><br></p>
<p class="p13">void getInvertPluginID(OFX::PluginFactoryArray &amp;ids)</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>static InvertPluginFactory p(kPluginIdentifier, kPluginVersionMajor, kPluginVersionMinor);</p>
<p class="p13"><span class="Apple-converted-space">    </span>ids.push_back(&amp;p);</p>
<p class="p13">}</p>
<p class="p2"><br></p>
<p class="p7">The plug-in must be registered with its raw ID (the plug-in identifier for the host application) and its version. The host application can then sort the plug-ins by versions and try to avoid duplicates.</p>
<p class="p7">Now that we have that small function, we need to define the InvertPluginFactory.</p>
<p class="p2"><br></p>
<p class="p11"><b><i>The Factory</i></b></p>
<p class="p2"><br></p>
<p class="p7">We declare the class in the .cpp file, using the handy macro that was created for that purpose:<span class="Apple-converted-space"> </span></p>
<table cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td colspan="2" valign="top" class="td1">
        <p class="p14">mDeclarePluginFactory(InvertPluginFactory, {}, {});</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" valign="top" class="td2">
        <p class="p15"><br></p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p2"><br></p>
<p class="p7">That macro just declares the class and its virtual functions. The virtual functions are the <b>actions</b> that a host can call on the factory, they are:</p>
<ul class="ul1">
  <li class="li9"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxActionLoad"><span class="s1">The load action</span></a></li>
  <li class="li9"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxActionUnload"><span class="s1">The unload action</span></a></li>
  <li class="li9"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxActionDescribe"><span class="s1">The describe action</span></a></li>
  <li class="li9"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectActionDescribeInContext"><span class="s1">The describe in context action</span></a></li>
  <li class="li9"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxActionCreateInstance"><span class="s1">The create instance action</span></a></li>
</ul>
<p class="p2"><br></p>
<p class="p13">#define mDeclarePluginFactory(CLASS, LOADFUNCDEF, UNLOADFUNCDEF) \</p>
<p class="p13"><span class="Apple-converted-space">  </span>class CLASS : public OFX::PluginFactoryHelper&lt;CLASS&gt; \</p>
<p class="p13"><span class="Apple-converted-space">  </span>{ \</p>
<p class="p13"><span class="Apple-converted-space">  </span>public: \</p>
<p class="p13"><span class="Apple-converted-space">  </span>CLASS(const std::string&amp; id, unsigned int verMaj, unsigned int verMin):OFX::PluginFactoryHelper&lt;CLASS&gt;(id, verMaj, verMin){} \</p>
<p class="p13"><span class="Apple-converted-space">  </span>virtual void load() LOADFUNCDEF ;\</p>
<p class="p13"><span class="Apple-converted-space">  </span>virtual void unload() UNLOADFUNCDEF ;\</p>
<p class="p13"><span class="Apple-converted-space">  </span>virtual void describe(OFX::ImageEffectDescriptor &amp;desc); \</p>
<p class="p13"><span class="Apple-converted-space">  </span>virtual void describeInContext(OFX::ImageEffectDescriptor &amp;desc, OFX::ContextEnum context); \</p>
<p class="p13"><span class="Apple-converted-space">  </span>virtual OFX::ImageEffect* createInstance(OfxImageEffectHandle handle, OFX::ContextEnum context); \</p>
<p class="p13"><span class="Apple-converted-space">  </span>};</p>
<p class="p2"><br></p>
<p class="p7">I won't go through the definition of those actions as the specification does a great job for that (just click on the links above). The 3 parameters of the factory declaring macro are the name of the factory, and 2 other arguments used wether you want to implement the load and unload actions or not.</p>
<p class="p7">In the general case you rarely need to implement those 2 actions, except if you need to do stuff right after the plug-in is loaded (application launch) and right before the plug-in is unloaded (application quit).</p>
<p class="p7">If you don't need to implement them, then do as the Invert example does, put an empty brace as parameter, indicating that the definition of the action is empty.</p>
<p class="p7">Otherwise, if you were to need to implement them, put a semi-colon <b>;</b> as parameter and then define the functions below.</p>
<p class="p2"><br></p>
<p class="p7">Let's take a look at the…</p>
<p class="p2"><br></p>
<p class="p16"><b>Create instance action:<span class="Apple-converted-space"> </span></b></p>
<p class="p2"><br></p>
<p class="p13">OFX::ImageEffect* InvertPluginFactory::createInstance(OfxImageEffectHandle handle, OFX::ContextEnum /*context*/)</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>return new InvertPlugin(handle);</p>
<p class="p13">}</p>
<p class="p2"><br></p>
<p class="p7">All it does is creating an instance of our plug-in class. We will cover the plug-in class later on when we're done with the factory.</p>
<p class="p2"><br></p>
<p class="p16"><b>The describe action:</b></p>
<p class="p2"><br></p>
<p class="p7">Defines the relevant properties of our plug-in so that the host can use it in an appropriate manner:</p>
<p class="p2"><br></p>
<p class="p13">void InvertPluginFactory::describe(OFX::ImageEffectDescriptor &amp;desc)</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>// basic labels</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setLabels(kPluginName, kPluginName, kPluginName);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setPluginGrouping(kPluginGrouping);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setPluginDescription(kPluginDescription);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// add the supported contexts</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.addSupportedContext(eContextFilter);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.addSupportedContext(eContextGeneral);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.addSupportedContext(eContextPaint);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// add supported pixel depths</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.addSupportedBitDepth(eBitDepthUByte);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.addSupportedBitDepth(eBitDepthUShort);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.addSupportedBitDepth(eBitDepthFloat);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// set a few flags</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setSingleInstance(false);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setHostFrameThreading(false);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setSupportsMultiResolution(true);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setSupportsTiles(true);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setTemporalClipAccess(false);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setRenderTwiceAlways(false);</p>
<p class="p13"><span class="Apple-converted-space">    </span>desc.setSupportsMultipleClipPARs(false);</p>
<p class="p17"><br></p>
<p class="p13">}</p>
<p class="p17"><br></p>
<p class="p7">The labels of the plug-in are essentially a duplicate of the name of the plug-in but that is meant to be seen in different places in the user interface. In our case we use the plug-in name for all 3 labels (label,shortLabel,longLabel).</p>
<p class="p7">The plug-in grouping, is the name of the group in which this plug-in will be found. If you were to have the grouping "Filter" then in Natron you would find your plug-in under the Filter menu…</p>
<p class="p7">You can also specify subgroups, such as: "MyPluginGroup/Filters".</p>
<p class="p7">The plug-in description is generally what is seen in the help window the host offers for that plug-in. In Natron this is what the user sees when clicking on the <b>?</b> button of the plug-in.</p>
<p class="p2"><br></p>
<p class="p7">Now we must define the contexts we can support. You almost always want to support the general context, this is the context that offers maximum flexibility to your plug-in. The filter context is essentially different of the General context</p>
<p class="p7">because it allows only 1 non optional input clip and doesn't allow masks.</p>
<p class="p7">The paint context is rarely used but just says that if a mask were to be defined, then its name should not be "Mask" but "Brush". Some host application could then in the paint context</p>
<p class="p7">offer a different use interface. In Natron however we do not and the paint context is essentially treated as other contexts.</p>
<p class="p7">As a general rule, try to support as many contexts as you can, this is cheap to do and offers maximum portability across all available host applications.</p>
<p class="p2"><br></p>
<p class="p7">The supported bit depths of the plug-in is important. This defines what kind of images you accept in input and what you can output. If you were say to support only byte (8bit) images then the host application would have to provide you 8bit input and output images. Note that some hosts (like Natron) use 32bit floating point images internally, and if you can this is better to support the highest bit depth. If you can't support 32bit images because the library you're using is 8bit (like OpenCV) then don't worry, the host application should normally be able to convert images from different bit depths on its own. You can check whether the application can do this pixel shuffling by checking the content of the global</p>
<p class="p13">ImageEffectHostDescription gHostDescription;</p>
<p class="p7">This struct offers many info related to the host currently invoking your plug-in and can be used to turn on/off special features of your plug-in that work only if the host application supports it.</p>
<p class="p7">Hopefully the support layer offers means (via templates of the processor class) to support all bit depths yourself.</p>
<p class="p2"><br></p>
<p class="p7">The last remaining flags are very important as they define how the render action is called and the type of image and render window that should be used.</p>
<p class="p7">I'll just provide links to the original definition of these flags as they are very well described in the official spec:</p>
<p class="p2"><br></p>
<ul class="ul1">
  <li class="li18"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPluginPropSingleInstance">kOfxImageEffectPluginPropSingleInstance</a><span class="s7"> </span><span class="s8">(Defaults to false)</span></li>
</ul>
<ul class="ul1">
  <li class="li18"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPluginPropHostFrameThreading">kOfxImageEffectPluginPropHostFrameThreading</a><span class="s7"> </span><span class="s8">(Defaults to true)</span></li>
  <li class="li18"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropSupportsMultiResolution">kOfxImageEffectPropSupportsMultiResolution</a><span class="s7"> </span><span class="s8">(Defaults to true)</span></li>
  <li class="li18"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropSupportsTiles">kOfxImageEffectPropSupportsTiles</a><span class="s7"> </span><span class="s8">(Defaults to true)</span></li>
  <li class="li18"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropTemporalClipAccess">kOfxImageEffectPropTemporalClipAccess</a><span class="s7"> </span><span class="s8">(Defaults to false)</span></li>
  <li class="li18"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPluginPropFieldRenderTwiceAlways">kOfxImageEffectPluginPropFieldRenderTwiceAlways</a><span class="s7"> </span><span class="s8">(Defaults to true)</span></li>
  <li class="li18"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropSupportsMultipleClipPARs">kOfxImageEffectPropSupportsMultipleClipPARs</a><span class="s7"> </span><span class="s8">(Defaults to false)<span class="Apple-converted-space"> </span></span></li>
  <li class="li18"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropSupportsMultipleClipDepths">kOfxImageEffectPropSupportsMultipleClipDepths</a><span class="s7"> </span><span class="s8">(Defaults to false)</span></li>
  <li class="li19"><span class="s9"><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPluginRenderThreadSafety">kOfxImageEffectPluginRenderThreadSafety</a></span><span class="s10"> </span>(Defaults to instance safe: any instance can have a single "render" call at any one time.)</li>
</ul>
<p class="p2"><br></p>
<p class="p7">The really tricky flags are:</p>
<p class="p2"><br></p>
<p class="p7">- Multi-resolution: Do you support input and output images which have different region of definition ? In this case they can have arbitrary size (different) and the origin can be something else than 0,0</p>
<p class="p7">- Tiles: Do you support render windows that are different than the full region of definition of an image ? If true then the render window provided as parameter of the render action can be set to a rectangle<span class="Apple-converted-space">  </span>smaller than the</p>
<p class="p7">actual region of definition of the image.</p>
<p class="p7">-<span class="Apple-converted-space">  </span>render thread safety: The default value expects that your plug-in is thread-safe over several instances. In Natron one instance of your plug-in is a node. Generally this default value is good enough, unless you have some dirty global state that you maintain. The best you can do is to have a fully safe thread-safety, in which case several render threads can call the render action simultaneously. The host would then call your render function simultaneously in 2 different cases:</p>
<ol class="ol1">
  <li class="li7">Because you set the host frame threading property to true and you're a fully-safe plug-in. In this case the host will slice up the render window by the amount of available threads and call as many parallel render as it needs.</li>
  <li class="li7">Because your instance is referenced several times in the compositing graph and there's several render threads ongoing (for example in Natron this would happen if you were to have 2 viewers plugged to the same node).</li>
</ol>
<p class="p2"><br></p>
<p class="p7">Depending on all the properties that you defined in the describe action, this is of <span class="s11"><b>YOUR RESPONSIBILITY</b></span> to check in the render action that the image and arguments provided correspond to all the properties you described.</p>
<p class="p7">If the image doesn't have a format you can exploit, then fail the render action by throwing the following exception:</p>
<p class="p13">OFX::throwSuiteStatusException(kOfxStatErrImageFormat);</p>
<p class="p7">You can also throw a kOfxStatFailed exception if the arguments aren't suited to your plug-in too. This is then the host responsibility to provide you arguments that are good enough for your plug-in, but catching errors ensures that your</p>
<p class="p7">plug-in doesn't crash the host application because the host did a mistake.</p>
<p class="p2"><br></p>
<p class="p16"><b>The describeInContext action:</b></p>
<p class="p2"><br></p>
<p class="p7">In this function we define our clips (inputs/output) and the parameters of the plug-in.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p13">void InvertPluginFactory::describeInContext(OFX::ImageEffectDescriptor &amp;desc, OFX::ContextEnum context)</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>// Source clip only in the filter context</p>
<p class="p13"><span class="Apple-converted-space">    </span>// create the mandated source clip</p>
<p class="p13"><span class="Apple-converted-space">    </span>ClipDescriptor *srcClip = desc.defineClip(kOfxImageEffectSimpleSourceClipName);</p>
<p class="p13"><span class="Apple-converted-space">    </span>srcClip-&gt;addSupportedComponent(ePixelComponentRGBA);</p>
<p class="p13"><span class="Apple-converted-space">    </span>srcClip-&gt;addSupportedComponent(ePixelComponentRGB);</p>
<p class="p13"><span class="Apple-converted-space">    </span>srcClip-&gt;addSupportedComponent(ePixelComponentAlpha);</p>
<p class="p13"><span class="Apple-converted-space">    </span>srcClip-&gt;setTemporalClipAccess(false);</p>
<p class="p13"><span class="Apple-converted-space">    </span>srcClip-&gt;setSupportsTiles(true);</p>
<p class="p13"><span class="Apple-converted-space">    </span>srcClip-&gt;setIsMask(false);</p>
<p class="p17"><span class="Apple-converted-space">    </span></p>
<p class="p13"><span class="Apple-converted-space">    </span>// create the mandated output clip</p>
<p class="p13"><span class="Apple-converted-space">    </span>ClipDescriptor *dstClip = desc.defineClip(kOfxImageEffectOutputClipName);</p>
<p class="p13"><span class="Apple-converted-space">    </span>dstClip-&gt;addSupportedComponent(ePixelComponentRGBA);</p>
<p class="p13"><span class="Apple-converted-space">    </span>dstClip-&gt;addSupportedComponent(ePixelComponentRGB);</p>
<p class="p13"><span class="Apple-converted-space">    </span>dstClip-&gt;addSupportedComponent(ePixelComponentAlpha);</p>
<p class="p13"><span class="Apple-converted-space">    </span>dstClip-&gt;setSupportsTiles(true);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>if (context == eContextGeneral || context == eContextPaint) {</p>
<p class="p13"><span class="Apple-converted-space">        </span>ClipDescriptor *maskClip = context == eContextGeneral ? desc.defineClip("Mask") : desc.defineClip("Brush");</p>
<p class="p13"><span class="Apple-converted-space">        </span>maskClip-&gt;addSupportedComponent(ePixelComponentAlpha);</p>
<p class="p13"><span class="Apple-converted-space">        </span>maskClip-&gt;setTemporalClipAccess(false);</p>
<p class="p13"><span class="Apple-converted-space">        </span>if (context == eContextGeneral) {</p>
<p class="p13"><span class="Apple-converted-space">            </span>maskClip-&gt;setOptional(true);</p>
<p class="p13"><span class="Apple-converted-space">        </span>}</p>
<p class="p13"><span class="Apple-converted-space">        </span>maskClip-&gt;setSupportsTiles(true);</p>
<p class="p13"><span class="Apple-converted-space">        </span>maskClip-&gt;setIsMask(true);</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// make some pages and to things in</p>
<p class="p13"><span class="Apple-converted-space">    </span>PageParamDescriptor *page = desc.definePageParam("Controls");</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>{</p>
<p class="p13"><span class="Apple-converted-space">        </span>OFX::BooleanParamDescriptor* param = desc.defineBooleanParam(kParamProcessR);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setLabels(kParamProcessRLabel, kParamProcessRLabel, kParamProcessRLabel);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setHint(kParamProcessRHint);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setDefault(true);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setLayoutHint(eLayoutHintNoNewLine);</p>
<p class="p13"><span class="Apple-converted-space">        </span>page-&gt;addChild(*param);</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>{</p>
<p class="p13"><span class="Apple-converted-space">        </span>OFX::BooleanParamDescriptor* param = desc.defineBooleanParam(kParamProcessG);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setLabels(kParamProcessGLabel, kParamProcessGLabel, kParamProcessGLabel);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setHint(kParamProcessGHint);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setDefault(true);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setLayoutHint(eLayoutHintNoNewLine);</p>
<p class="p13"><span class="Apple-converted-space">        </span>page-&gt;addChild(*param);</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>{</p>
<p class="p13"><span class="Apple-converted-space">        </span>OFX::BooleanParamDescriptor* param = desc.defineBooleanParam( kParamProcessB );</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setLabels(kParamProcessBLabel, kParamProcessBLabel, kParamProcessBLabel);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setHint(kParamProcessBHint);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setDefault(true);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setLayoutHint(eLayoutHintNoNewLine);</p>
<p class="p13"><span class="Apple-converted-space">        </span>page-&gt;addChild(*param);</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>{</p>
<p class="p13"><span class="Apple-converted-space">        </span>OFX::BooleanParamDescriptor* param = desc.defineBooleanParam( kParamProcessA );</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setLabels(kParamProcessALabel, kParamProcessALabel, kParamProcessALabel);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setHint(kParamProcessAHint);</p>
<p class="p13"><span class="Apple-converted-space">        </span>param-&gt;setDefault(true);</p>
<p class="p13"><span class="Apple-converted-space">        </span>page-&gt;addChild(*param);</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>ofxsPremultDescribeParams(desc, page);</p>
<p class="p13"><span class="Apple-converted-space">    </span>ofxsMaskMixDescribeParams(desc, page);</p>
<p class="p13">}</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">First we define our clips. Your plug-in <b>MUST</b> have an output clip. Then depending in which context the describe action is called, you can define one or more input clips.</p>
<p class="p7">The input clips in Natron are seen from left to right in reverse order of the one you declared your clips. That is if you define your clip "MyInput1" and "MyInput2" in that order, Natron</p>
<p class="p7">would then instantiate the node this way:</p>
<p class="p2"><br></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>MyInput2<span class="Apple-converted-space">    </span>MyInput1</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">        </span>\<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>/</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>\<span class="Apple-tab-span">	</span>/</p>
<p class="p7"><span class="Apple-tab-span">	</span>----------------------------</p>
<p class="p7"><span class="Apple-tab-span">	</span>|<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>|</p>
<p class="p7"><span class="Apple-tab-span">	</span>|<span class="Apple-tab-span">	</span>MyEffect<span class="Apple-tab-span">	</span>|</p>
<p class="p7"><span class="Apple-tab-span">	</span>|<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>|</p>
<p class="p7"><span class="Apple-tab-span">	</span>----------------------------</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">If you're in the general context or paint context your effect can then also have a mask clip. Generally the mask is a clip that only supports alpha images. Don't forget to specify whether a clip is optional or not (an optional clip is then not mandatory to render) and to define which components your clip support.</p>
<p class="p2"><br></p>
<p class="p7">After that you would basically declare all the parameters.</p>
<p class="p7">Generally you define a page parameter which will contain some other children parameters. A page parameter in Natron is represented as a tab in the settings panel of the node.</p>
<p class="p7">You can also create subgroups of parameters by defining a group parameter.<span class="Apple-converted-space"> </span></p>
<p class="p7">A parameter should always belong to a page. If you fail to put it into a page, then Natron by default will put it in some default tab (generally the "Node" tab).</p>
<p class="p2"><br></p>
<p class="p7">Each parameter have a label (the visible label on the left hand side of the parameter in the settings panel) and a script name. This is important to have some sort of standard for naming.</p>
<p class="p7">Otherwise the user ends-up with a poorly aligned user interface and more importantly the scripting of the application gets messier because it is not easy to reference parameters in a script which have</p>
<p class="p7">space into their name!</p>
<p class="p2"><br></p>
<p class="p7">Generally we use the following convention for naming parameters: (this is what can be used in a script)</p>
<p class="p2"><br></p>
<p class="p7">myParameter1</p>
<p class="p7">myLongParameterWithMoreThan1Word</p>
<p class="p2"><br></p>
<p class="p7">And this convention for naming labels: (this is what is seen in the user interface)</p>
<p class="p2"><br></p>
<p class="p7">My parameter 1</p>
<p class="p7">My long parameter with more than 1 word</p>
<p class="p2"><br></p>
<p class="p7">We also define macros for all these strings in the beginning of the .cpp file so that it makes it easier to make quick changes.</p>
<p class="p2"><br></p>
<p class="p7">The hint of a parameter is the string that will be displayed in the tooltip when the user hovers with the mouse the parameter.<span class="Apple-converted-space"> </span></p>
<p class="p7">You should always set the default value for your parameter.</p>
<p class="p7">Almost all parameters animates by default: In Natron they will have the animation button on the right hand side. If you want to disable animation, you need to explicitly set the animation disabled.</p>
<p class="p7">The following<span class="Apple-converted-space">  </span>parameters on the other hand do not animate by default : String,Boolean,Choice, you need to explicitly enable animation on them if you want them to animate.</p>
<p class="p2"><br></p>
<p class="p7">The layout hint is a hint to the application as to whether the parameters should be on the same line or not. By default a new parameter makes a new line.</p>
<p class="p2"><br></p>
<p class="p7">We're now ready and set to talk about the plug-in class...</p>
<p class="p2"><br></p>
<p class="p11"><b><i>The plug-in</i></b></p>
<p class="p2"><br></p>
<p class="p7">Your class should inherit the OFX::ImageEffect class which gives you access to a bunch of virtual functions to implement. Those functions represent the actions the host can call on your plug-in.</p>
<p class="p7">All actions of the plug-in have a default behaviour except the render action and generally you don't need to implement all actions.</p>
<p class="p2"><br></p>
<p class="p7">In the Invert plug-in, we only needed to implement 3 actions:</p>
<p class="p7">- The render action</p>
<p class="p7">- The isIdentity action</p>
<p class="p7">- the changed clip action</p>
<p class="p2"><br></p>
<p class="p16"><b>The constructor:</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p13">InvertPlugin(OfxImageEffectHandle handle)</p>
<p class="p13"><span class="Apple-converted-space">            </span>: ImageEffect(handle)</p>
<p class="p13"><span class="Apple-converted-space">            </span>, dstClip_(0)</p>
<p class="p13"><span class="Apple-converted-space">            </span>, srcClip_(0)</p>
<p class="p13"><span class="Apple-converted-space">    </span>{</p>
<p class="p13"><span class="Apple-converted-space">        </span>dstClip_ = fetchClip(kOfxImageEffectOutputClipName);</p>
<p class="p13"><span class="Apple-converted-space">        </span>assert(dstClip_ &amp;&amp; (dstClip_-&gt;getPixelComponents() == ePixelComponentRGB || dstClip_-&gt;getPixelComponents() == ePixelComponentRGBA || dstClip_-&gt;getPixelComponents() == ePixelComponentAlpha));</p>
<p class="p13"><span class="Apple-converted-space">        </span>srcClip_ = fetchClip(kOfxImageEffectSimpleSourceClipName);</p>
<p class="p13"><span class="Apple-converted-space">        </span>assert(srcClip_ &amp;&amp; (srcClip_-&gt;getPixelComponents() == ePixelComponentRGB || srcClip_-&gt;getPixelComponents() == ePixelComponentRGBA || srcClip_-&gt;getPixelComponents() == ePixelComponentAlpha));</p>
<p class="p13"><span class="Apple-converted-space">        </span>maskClip_ = getContext() == OFX::eContextFilter ? NULL : fetchClip(getContext() == OFX::eContextPaint ? "Brush" : "Mask");</p>
<p class="p13"><span class="Apple-converted-space">        </span>assert(!maskClip_ || maskClip_-&gt;getPixelComponents() == ePixelComponentAlpha);</p>
<p class="p13"><span class="Apple-converted-space">        </span>_paramProcessR = fetchBooleanParam(kParamProcessR);</p>
<p class="p13"><span class="Apple-converted-space">        </span>_paramProcessG = fetchBooleanParam(kParamProcessG);</p>
<p class="p13"><span class="Apple-converted-space">        </span>_paramProcessB = fetchBooleanParam(kParamProcessB);</p>
<p class="p13"><span class="Apple-converted-space">        </span>_paramProcessA = fetchBooleanParam(kParamProcessA);</p>
<p class="p13"><span class="Apple-converted-space">        </span>assert(_paramProcessR &amp;&amp; _paramProcessG &amp;&amp; _paramProcessB &amp;&amp; _paramProcessA);</p>
<p class="p13"><span class="Apple-converted-space">        </span>_premult = fetchBooleanParam(kParamPremult);</p>
<p class="p13"><span class="Apple-converted-space">        </span>_premultChannel = fetchChoiceParam(kParamPremultChannel);</p>
<p class="p13"><span class="Apple-converted-space">        </span>assert(_premult &amp;&amp; _premultChannel);</p>
<p class="p13"><span class="Apple-converted-space">        </span>_mix = fetchDoubleParam(kParamMix);</p>
<p class="p13"><span class="Apple-converted-space">        </span>_maskInvert = fetchBooleanParam(kParamMaskInvert);</p>
<p class="p13"><span class="Apple-converted-space">        </span>assert(_mix &amp;&amp; _maskInvert);</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><br></p>
<p class="p7">In the constructor, we fetch all<span class="Apple-converted-space">  </span>clips and parameters that we previously defined in the factory.</p>
<p class="p7">At this point, if the plug-in would be instantiated from a project saved by a user with serialised values, all the parameters would already have their value restored by now. If you do not want a parameter to be persistent (i.e serialised) then call setIsPersistent(false) on the parameter descriptor in the describeInContext action.</p>
<p class="p2"><br></p>
<p class="p16"><b>The isIdentity action:</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">As a reminder, a plug-in is identity when it doesn't transform in any way the source image. In our case if the R,G,B,A parameters are checked off, then our plug-in doesn't do anything anymore.<span class="Apple-converted-space"> </span></p>
<p class="p7">So in the isIdentity action, we just check if at least one the parameters is checked. If not, then we can say we're identity of the input clip at the same time that was given in parameter.</p>
<p class="p2"><br></p>
<p class="p13">bool</p>
<p class="p13">InvertPlugin::isIdentity(const IsIdentityArguments &amp;args, Clip * &amp;identityClip, double &amp;/*identityTime*/)</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>bool red, green, blue, alpha;</p>
<p class="p13"><span class="Apple-converted-space">    </span>double mix;</p>
<p class="p13"><span class="Apple-converted-space">    </span>_paramProcessR-&gt;getValueAtTime(args.time, red);</p>
<p class="p13"><span class="Apple-converted-space">    </span>_paramProcessG-&gt;getValueAtTime(args.time, green);</p>
<p class="p13"><span class="Apple-converted-space">    </span>_paramProcessB-&gt;getValueAtTime(args.time, blue);</p>
<p class="p13"><span class="Apple-converted-space">    </span>_paramProcessA-&gt;getValueAtTime(args.time, alpha);</p>
<p class="p13"><span class="Apple-converted-space">    </span>_mix-&gt;getValueAtTime(args.time, mix);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>if (mix == 0. || (!red &amp;&amp; !green &amp;&amp; !blue &amp;&amp; !alpha)) {</p>
<p class="p13"><span class="Apple-converted-space">        </span>identityClip = srcClip_;</p>
<p class="p13"><span class="Apple-converted-space">        </span>return true;</p>
<p class="p13"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p13"><span class="Apple-converted-space">        </span>return false;</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p13">}</p>
<p class="p17"><br></p>
<p class="p2"><br></p>
<p class="p7">Note here that we use the getValueAtTime() function on the parameters and not the getValue() function. We do this because those parameter animate and we want to fetch their exact value at the time given in parameter of the action.</p>
<p class="p7">If you were to call getValue() only, then the host would also call getValueAtTime() but it would take some overhead because it would need to also fetch the current time at which you called the function.</p>
<p class="p2"><br></p>
<p class="p7">So as a general rule of thumbs:<span class="Apple-converted-space"> </span></p>
<p class="p7">- Call getValueAtTime for parameters that animate</p>
<p class="p7">- Call getValue for all parameters that do not animate</p>
<p class="p2"><br></p>
<p class="p16"><b>The changedClip action:</b></p>
<p class="p2"><br></p>
<p class="p13">void</p>
<p class="p13">InvertPlugin::changedClip(const InstanceChangedArgs &amp;args, const std::string &amp;clipName)</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>if (clipName == kOfxImageEffectSimpleSourceClipName &amp;&amp; srcClip_ &amp;&amp; args.reason == OFX::eChangeUserEdit) {</p>
<p class="p13"><span class="Apple-converted-space">        </span>switch (srcClip_-&gt;getPreMultiplication()) {</p>
<p class="p13"><span class="Apple-converted-space">            </span>case eImageOpaque:</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p13"><span class="Apple-converted-space">            </span>case eImagePreMultiplied:</p>
<p class="p13"><span class="Apple-converted-space">                </span>_premult-&gt;setValue(true);</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p13"><span class="Apple-converted-space">            </span>case eImageUnPreMultiplied:</p>
<p class="p13"><span class="Apple-converted-space">                </span>_premult-&gt;setValue(false);</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p13"><span class="Apple-converted-space">        </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p13">}</p>
<p class="p12"><br></p>
<p class="p2"><br></p>
<p class="p7">In the Invert plug-in we have a special parameter that can be checked to unpremultiply the colour channels (RGB) by the Alpha channel before inverting the image.</p>
<p class="p7">This action is called when the user changes a connection of the plug-in: when the input arrow is connected to another node, this action handler will be called and you'll be able to know a bunch of information from the input clip.</p>
<p class="p7">In our case we query whether the input clip is a premultiplied image or not and set the value of the Unpremultiply parameter according to the input image state.</p>
<p class="p2"><br></p>
<p class="p16"><b>The render action:</b></p>
<p class="p2"><br></p>
<p class="p13">void</p>
<p class="p13">InvertPlugin::render(const OFX::RenderArguments &amp;args)</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>// instantiate the render code based on the pixel depth of the dst clip</p>
<p class="p13"><span class="Apple-converted-space">    </span>OFX::BitDepthEnum <span class="Apple-converted-space">      </span>dstBitDepth<span class="Apple-converted-space">    </span>= dstClip_-&gt;getPixelDepth();</p>
<p class="p13"><span class="Apple-converted-space">    </span>OFX::PixelComponentEnum dstComponents<span class="Apple-converted-space">  </span>= dstClip_-&gt;getPixelComponents();</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// do the rendering</p>
<p class="p13"><span class="Apple-converted-space">    </span>if (dstComponents == OFX::ePixelComponentRGBA) {</p>
<p class="p13"><span class="Apple-converted-space">        </span>switch (dstBitDepth) {</p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthUByte : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;unsigned char, 4, 255&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthUShort : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;unsigned short, 4, 65535&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthFloat : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;float, 4, 1&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p13"><span class="Apple-converted-space">            </span>default :</p>
<p class="p13"><span class="Apple-converted-space">                </span>OFX::throwSuiteStatusException(kOfxStatErrUnsupported);</p>
<p class="p13"><span class="Apple-converted-space">        </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>} else if (dstComponents == OFX::ePixelComponentRGB) {</p>
<p class="p13"><span class="Apple-converted-space">        </span>switch (dstBitDepth) {</p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthUByte : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;unsigned char, 3, 255&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthUShort : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;unsigned short, 3, 65535&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthFloat : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;float, 3, 1&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p13"><span class="Apple-converted-space">            </span>default :</p>
<p class="p13"><span class="Apple-converted-space">                </span>OFX::throwSuiteStatusException(kOfxStatErrUnsupported);</p>
<p class="p13"><span class="Apple-converted-space">        </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p13"><span class="Apple-converted-space">        </span>assert(dstComponents == OFX::ePixelComponentAlpha);</p>
<p class="p13"><span class="Apple-converted-space">        </span>switch (dstBitDepth) {</p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthUByte : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;unsigned char, 1, 255&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthUShort : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;unsigned short, 1, 65535&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">            </span>case OFX::eBitDepthFloat : {</p>
<p class="p13"><span class="Apple-converted-space">                </span>ImageInverter&lt;float, 1, 1&gt; fred(*this);</p>
<p class="p13"><span class="Apple-converted-space">                </span>setupAndProcess(fred, args);</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p13"><span class="Apple-converted-space">            </span>default :</p>
<p class="p13"><span class="Apple-converted-space">                </span>OFX::throwSuiteStatusException(kOfxStatErrUnsupported);</p>
<p class="p13"><span class="Apple-converted-space">        </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p13">}</p>
<p class="p2"><br></p>
<p class="p7">In this function we instantiate the processor that will do the job with the good parameters.</p>
<p class="p7">We query the bit depth and the pixel components of the output clip and instantiate the processor with the template parameters according to the bit depth and the image components.</p>
<p class="p7">We then can call the setupAndProcess function which will continue setting up the render.</p>
<p class="p2"><br></p>
<p class="p13">void</p>
<p class="p13">InvertPlugin::setupAndProcess(InvertBase &amp;processor, const OFX::RenderArguments &amp;args)</p>
<p class="p13">{</p>
<p class="p13"><span class="Apple-converted-space">    </span>// get a dst image</p>
<p class="p13"><span class="Apple-converted-space">    </span>std::auto_ptr&lt;OFX::Image&gt; dst(dstClip_-&gt;fetchImage(args.time));</p>
<p class="p13"><span class="Apple-converted-space">    </span>if (!dst.get()) {</p>
<p class="p13"><span class="Apple-converted-space">        </span>OFX::throwSuiteStatusException(kOfxStatFailed);</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>OFX::BitDepthEnum dstBitDepth <span class="Apple-converted-space">      </span>= dst-&gt;getPixelDepth();</p>
<p class="p13"><span class="Apple-converted-space">    </span>OFX::PixelComponentEnum dstComponents<span class="Apple-converted-space">  </span>= dst-&gt;getPixelComponents();</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// fetch main input image</p>
<p class="p13"><span class="Apple-converted-space">    </span>std::auto_ptr&lt;OFX::Image&gt; src(srcClip_-&gt;fetchImage(args.time));</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// make sure bit depths are sane</p>
<p class="p13"><span class="Apple-converted-space">    </span>if (src.get()) {</p>
<p class="p13"><span class="Apple-converted-space">        </span>OFX::BitDepthEnum<span class="Apple-converted-space">    </span>srcBitDepth<span class="Apple-converted-space">      </span>= src-&gt;getPixelDepth();</p>
<p class="p13"><span class="Apple-converted-space">        </span>OFX::PixelComponentEnum srcComponents = src-&gt;getPixelComponents();</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">        </span>// see if they have the same depths and bytes and all</p>
<p class="p13"><span class="Apple-converted-space">        </span>if (srcBitDepth != dstBitDepth || srcComponents != dstComponents) {</p>
<p class="p13"><span class="Apple-converted-space">            </span>OFX::throwSuiteStatusException(kOfxStatErrImageFormat);</p>
<p class="p13"><span class="Apple-converted-space">        </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// auto ptr for the mask.</p>
<p class="p13"><span class="Apple-converted-space">    </span>std::auto_ptr&lt;OFX::Image&gt; mask((getContext() != OFX::eContextFilter) ? maskClip_-&gt;fetchImage(args.time) : 0);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// do we do masking</p>
<p class="p13"><span class="Apple-converted-space">    </span>if (getContext() != OFX::eContextFilter &amp;&amp; maskClip_-&gt;isConnected()) {</p>
<p class="p13"><span class="Apple-converted-space">        </span>// say we are masking</p>
<p class="p13"><span class="Apple-converted-space">        </span>processor.doMasking(true);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">        </span>// Set it in the processor</p>
<p class="p13"><span class="Apple-converted-space">        </span>processor.setMaskImg(mask.get());</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>bool red, green, blue, alpha;</p>
<p class="p13"><span class="Apple-converted-space">    </span>_paramProcessR-&gt;getValueAtTime(args.time, red);</p>
<p class="p13"><span class="Apple-converted-space">    </span>_paramProcessG-&gt;getValueAtTime(args.time, green);</p>
<p class="p13"><span class="Apple-converted-space">    </span>_paramProcessB-&gt;getValueAtTime(args.time, blue);</p>
<p class="p13"><span class="Apple-converted-space">    </span>_paramProcessA-&gt;getValueAtTime(args.time, alpha);</p>
<p class="p13"><span class="Apple-converted-space">    </span>bool premult;</p>
<p class="p13"><span class="Apple-converted-space">    </span>int premultChannel;</p>
<p class="p13"><span class="Apple-converted-space">    </span>_premult-&gt;getValueAtTime(args.time, premult);</p>
<p class="p13"><span class="Apple-converted-space">    </span>_premultChannel-&gt;getValueAtTime(args.time, premultChannel);</p>
<p class="p13"><span class="Apple-converted-space">    </span>double mix;</p>
<p class="p13"><span class="Apple-converted-space">    </span>_mix-&gt;getValueAtTime(args.time, mix);</p>
<p class="p13"><span class="Apple-converted-space">    </span>bool maskInvert;</p>
<p class="p13"><span class="Apple-converted-space">    </span>_maskInvert-&gt;getValueAtTime(args.time, maskInvert);</p>
<p class="p13"><span class="Apple-converted-space">    </span>processor.setValues(red, green, blue, alpha, premult, premultChannel, mix, maskInvert);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// set the images</p>
<p class="p13"><span class="Apple-converted-space">    </span>processor.setDstImg(dst.get());</p>
<p class="p13"><span class="Apple-converted-space">    </span>processor.setSrcImg(src.get());</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// set the render window</p>
<p class="p13"><span class="Apple-converted-space">    </span>processor.setRenderWindow(args.renderWindow);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">    </span>// Call the base class process member, this will call the derived templated process code</p>
<p class="p13"><span class="Apple-converted-space">    </span>processor.process();</p>
<p class="p13">}</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">First thing we do is fetching the output image in which we will render. If the pointer is NULL then we fail the render of course, there must be something terribly wrong in the host application for that to happen.</p>
<p class="p7">We then again fetch the bit depth and the pixel components of the output image.</p>
<p class="p2"><br></p>
<p class="p7">Now we fetch the input image too. One thing we didn't do here but that we should have done is checking whether the clip is actually connected before fetching the image. Some hosts return garbage image when the clip is disconnected.<span class="Apple-converted-space"> </span></p>
<p class="p7">In Natron we return a NULL image, but the plug-in should always check whether a non-optional input clip is connected before fetching its image.</p>
<p class="p2"><br></p>
<p class="p7">If the image returned is NULL then you can do 2 possible things: render black and transparent yourself in the processor (that's what we do in the invert plug-in) or fail the render and the host will probably render black on its own.</p>
<p class="p2"><br></p>
<p class="p7">The next thing we do is checking that the input image and output image bit depths and components match. Remember that in the describe function we set the<span class="Apple-converted-space">  </span><a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropSupportsMultipleClipPARs"><span class="s12">kOfxImageEffectPropSupportsMultipleClipPARs</span></a></p>
<ul class="ul1">
  <li class="li7">and <a href="http://openfx.sourceforge.net/Documentation/1.3/ofxProgrammingReference.html#kOfxImageEffectPropSupportsMultipleClipDepths"><span class="s12">kOfxImageEffectPropSupportsMultipleClipDepths</span></a> properties to false, indicating that we expect the input and output images to have the same properties.</li>
</ul>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">Now depending on the context we can also fetch our mask. If the mask is NULL because it is not connected, this not an issue: this is an optional input and your processing code should take into account the fact that this mask might not exist.</p>
<p class="p2"><br></p>
<p class="p7">We then fetch all the values from the parameters that will have effect on the processing code and pass them to the processor in the setValues(…) function that we created. getValue() and getValueAtTime() can be expensive, hence it is better to call them now and once than in the processor class which will be multi-threaded hence duplicating the API calls.</p>
<p class="p7">Don't forget to set the src and dst image pointers to the processor as well as the render window. At this point you're ready to call the process() function. This function will ask the host to launch multiple threads to render the code inside the processor class. This is a blocking call and will return only when all threads are finished rendering.</p>
<p class="p2"><br></p>
<p class="p7">Note that it is <span class="s13"><b>FORBIDDEN</b></span> to set values of parameters (i.e: calling setValue() and setValueAtTime()) in the render action. If you were to update some parameters after your render call then this is not the place to do so.</p>
<p class="p7">Reminder from the spec:</p>
<p class="p2"><br></p>
<p class="p20"><b><i>Setting Parameters</i></b></p>
<p class="p21"><i>Plugins are free to set parameters in limited set of circumstances, typically relating to user interaction. You can only set parameters in the following actions passed to the plug-in's main entry function...</i></p>
<ul class="ul1">
  <li class="li22"><i>The Create Instance Action</i></li>
  <li class="li23"><span class="s2"><i>The </i></span><i>The Begin Instance Changed Action</i></li>
  <li class="li23"><span class="s2"><i>The </i></span><i>The Instance Changed Action</i></li>
  <li class="li23"><span class="s2"><i>The </i></span><i>The End Instance Changed Action</i></li>
  <li class="li23"><span class="s2"><i>The </i></span><i>The Sync Private Data Action</i></li>
</ul>
<ul class="ul1">
  <li class="li7"></li>
</ul>
<p class="p2"><br></p>
<p class="p2"><br></p>
<ul class="ul1">
  <li class="li11"><b><i>The processor</i></b></li>
</ul>
<p class="p2"><br></p>
<p class="p7">This class is actually decomposed in 2 classes:<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p7">- A base class, which is used by the plug-in in setupAndProcess and avoids templating everything where we pass the processor in arguments.</p>
<p class="p7">This base class only holds the setters and getters for parameters values and images pointers.</p>
<p class="p2"><br></p>
<p class="p7">- A derived class which is templated by the bit depth (the pixel type here: unsigned char,unsigned short or float), the number of components and the maximum value for that bit depth.</p>
<p class="p2"><br></p>
<p class="p7">The only relevant function in the processor is the…</p>
<p class="p2"><br></p>
<p class="p16"><b>multiThreadProcessImages function:</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p7">In the invert plug-in we do a special thing here: we template a new function named process() with the parameters of the plug-in (process red, process green , process blue, process alpha). The reason we do that is that it creates very well</p>
<p class="p7">optimised code thanks to the compiler.</p>
<p class="p7">So here the interesting function in the Invert example is actually the process function….</p>
<p class="p2"><br></p>
<p class="p13">template&lt;bool dored, bool dogreen, bool doblue, bool doalpha&gt;</p>
<p class="p13"><span class="Apple-converted-space">    </span>void process(const OfxRectI&amp; procWindow)</p>
<p class="p13"><span class="Apple-converted-space">    </span>{</p>
<p class="p13"><span class="Apple-converted-space">        </span>float unpPix[4];</p>
<p class="p13"><span class="Apple-converted-space">        </span>float tmpPix[4];</p>
<p class="p13"><span class="Apple-converted-space">        </span>for (int y = procWindow.y1; y &lt; procWindow.y2; y++) {</p>
<p class="p13"><span class="Apple-converted-space">            </span>if (_effect.abort()) {</p>
<p class="p13"><span class="Apple-converted-space">                </span>break;</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">            </span>PIX *dstPix = (PIX *) _dstImg-&gt;getPixelAddress(procWindow.x1, y);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">            </span>for (int x = procWindow.x1; x &lt; procWindow.x2; x++) {</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">                </span>const PIX *srcPix = (const PIX *)<span class="Apple-converted-space">  </span>(_srcImg ? _srcImg-&gt;getPixelAddress(x, y) : 0);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">                </span>// do we have a source image to scale up</p>
<p class="p13"><span class="Apple-converted-space">                </span>ofxsUnPremult&lt;PIX, nComponents, maxValue&gt;(srcPix, unpPix, _premult, _premultChannel);</p>
<p class="p13"><span class="Apple-converted-space">                </span>tmpPix[0] = dored <span class="Apple-converted-space">  </span>? (1. - unpPix[0]) : unpPix[0];</p>
<p class="p13"><span class="Apple-converted-space">                </span>tmpPix[1] = dogreen ? (1. - unpPix[1]) : unpPix[1];</p>
<p class="p13"><span class="Apple-converted-space">                </span>tmpPix[2] = doblue<span class="Apple-converted-space">  </span>? (1. - unpPix[2]) : unpPix[2];</p>
<p class="p13"><span class="Apple-converted-space">                </span>tmpPix[3] = doalpha ? (1. - unpPix[3]) : unpPix[3];</p>
<p class="p13"><span class="Apple-converted-space">                </span>ofxsPremultMaskMixPix&lt;PIX, nComponents, maxValue, true&gt;(tmpPix, _premult, _premultChannel, x, y, srcPix, _doMasking, _maskImg, _mix, _maskInvert, dstPix);</p>
<p class="p17"><br></p>
<p class="p13"><span class="Apple-converted-space">                </span>// increment the dst pixel</p>
<p class="p13"><span class="Apple-converted-space">                </span>dstPix += nComponents;</p>
<p class="p13"><span class="Apple-converted-space">            </span>}</p>
<p class="p13"><span class="Apple-converted-space">        </span>}</p>
<p class="p13"><span class="Apple-converted-space">    </span>}</p>
<p class="p17"><br></p>
<p class="p7">This function takes in parameter for 1 thread what portion of the image it should render (procWindow). Typically the more threads the end-user computer has, the smaller the procWindow will be.<span class="Apple-converted-space"> </span></p>
<p class="p7">This function will be called by the host with new threads<span class="Apple-converted-space">  </span>it has launched using the multi-thread suite. That's exactly what does the processor.process() function in the setupAndProcess code.</p>
<p class="p7">Make sure that the code in this function can be well multi-threaded and doesn't require much synchronisation overhead between the threads, in which case you would be better off doing that processing directly in the<span class="Apple-converted-space"> </span></p>
<p class="p7">render function without requiring launching new threads.</p>
<p class="p2"><br></p>
<p class="p7">In this example we just loop over the scan lines first and the over each pixel in a scan-line.<span class="Apple-converted-space"> </span></p>
<p class="p7">At each loop, we check whether we should abort processing. If the function abort() returns true then we must cancel processing; this can be due to user interaction and generally returning the fastest possible ensures that the user can have responsive interaction and image renders.</p>
<p class="p2"><br></p>
<p class="p7">We then use the ofxsUnPremult and ofxsPremultMaskMixPix to actually do the processing. These are functions that we created in the <a href="https://github.com/devernay/openfx-supportext"><span class="s5">SupportExt repository</span></a><span class="Apple-converted-space">  </span>which helps us to write processors.<span class="Apple-converted-space">  </span>We created them because most of the processors across different plug-ins share a good amount of code and factorizing that into unique functions is easier to maintain. Plus improving one of the function, improves all plug-ins at once.</p>
<p class="p2"><br></p>
<p class="p7">We're done here for the walkthrough of the Invert plug-in.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
</body>
</html>
